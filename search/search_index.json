{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ImageryClient","text":"<p> Connectomics data often involves a combination of microscopy imagery and segmentation, labels of distinct objects applied to this imagery. While exploring the data in tools like Neuroglancer is great, a common task is often to make figures overlaying 2d images and segmentation sliced from the larger data. ImageryClient is designed to make it easy to generate aligned cutouts from imagery and segmentation, and make it efficient to produce attractive, publication-ready overlay images.</p> <p>Because of the size of these volumes, cloud-based serverless n-d array file storage systems are often used to host this data. CloudVolume has become an excellent general purpose tool for accessing such data. However, imagery and segmentation for the same data are hosted at distinct cloud locations and can differ in basic properties like base resolution. Moreover, imagery and segmentation have data that means intrensically different things. Values in imagery indicate pixel intensity in order to produce a picture, while values in segmentation indicate the object id at a given location. ImageryClient acts as a front end for making aligned cutouts from multiple cloudvolume sources, splitting segmentations into masks for each object, and more.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Important</p> <p>If using imageryclient on a CAVE-hosted dataset, we recommend installing CAVEclient for easier access to data. If so, please see the CAVEclient documentation for more information.</p> <p>We make use of Numpy arrays and Pillow Images to represent data. Both are extremely rich tools, and to learn more about them please see the appropriate documentation for information about saving data to image files and more. </p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>ImageryClient can be installed with pip:</p> <p><code>pip install imageryclient</code></p> <p>While not required, if you are using a CAVE-hosted dataset, installing CAVEclient will make your life much easier.</p>"},{"location":"getting_started/#troubleshooting","title":"Troubleshooting","text":"<p>If you have installation issues due to CloudVolume, which can have a complex set of requirements, we recommend looking at its github issues page for help.</p>"},{"location":"getting_started/#basic-example","title":"Basic example","text":"<p>A small example that uses all of the major components of ImageryClient: Downloading aligned images and segmentation, specifying specific segmentations to visualize, and generating an image overlay. This uses the pubically available Kasthuri et al. 2014 dataset.</p> <pre><code>import imageryclient as ic\n\nimg_src = 'precomputed://gs://neuroglancer-public-data/kasthuri2011/image_color_corrected'\nseg_src = 'precomputed://gs://neuroglancer-public-data/kasthuri2011/ground_truth'\n\nimg_client = ic.ImageryClient(image_source=img_src, segmentation_source=seg_src)\n\nbounds = [\n    [5119, 8477, 1201],\n    [5519, 8877, 1202]\n]\nroot_ids = [2282, 4845]\n\nimage, segs = img_client.image_and_segmentation_cutout(bounds,\n                                                       split_segmentations=True,\n                                                       root_ids=root_ids)\n\n\nic.composite_overlay(segs, imagery=image)\n</code></pre> <p>Figure 1: Expected imagery overlay from the code above</p>"},{"location":"images/","title":"Using ImageryClient","text":"<p>Here, we will use the ImageryClient to get some data from the Kasthuri et al. 2014 dataset hosted by Google. In its simplest form, we just intialize an ImageryClient object with an image cloudpath and a segmentation cloudpath. Values are taken from the layers in the linked neuroglancer state.</p> <pre><code>import imageryclient as ic\n\nimg_src = 'precomputed://gs://neuroglancer-public-data/kasthuri2011/image_color_corrected'\nseg_src = 'precomputed://gs://neuroglancer-public-data/kasthuri2011/ground_truth'\n\nimg_client = ic.ImageryClient(image_source=img_src, segmentation_source=seg_src)\n</code></pre>"},{"location":"images/#imagery-cutouts","title":"Imagery cutouts","text":"<p>Cutouts are defined by their bounds, which can be specified by providing bounds. The most direct form is a pair of points representing the upper and lower corners of the bounding box. By default, coordinates are in the default resolution of the imagery as you would see in neuroglancer.</p> <pre><code>bounds = [\n    [5119, 8477, 1201],\n    [5519, 8877, 1202]\n]\n\nimage = img_client.image_cutout(bounds)\n\n# Use PIL to visualize\nfrom PIL import Image\nImage.fromarray(image.T)\n</code></pre> <p>Figure 1: A 2d image cutout at full resolution specified by bounds</p> <p>Since often we are using analysis points to center an image on, we can alternatively define a center point and the width/height/depth of the bounding box (in voxels). The same image could be achived from this specification.</p> <pre><code>ctr = [5319, 8677, 1201]\nimg_width = 400\nimage = img_client.image_cutout(ctr, bbox_size=(img_width, img_width))\n</code></pre> <p>You can also generate bounds from a center and size.</p> <pre><code>bounds = ic.bounds_from_center(ctr, width=img_width, height=img_width, depth=1)\n</code></pre>"},{"location":"images/#resolution","title":"Resolution","text":"<p>A very important element in ImageryClient is the resolution, which specifies the units that you are using when providing bounds. You can check the resolution that the client is expecting with <code>img_client.resolution</code>. The resolution will default to the highest resolution available for the imagery, but you can specify another resolution manually. For example, to say that you are going to provide bounds in <code>[8,8,30]</code> voxel units, you would add the <code>resolution</code> argument:</p> <pre><code>img_client = ic.ImageryClient(..., resolution=[8,8,30])\n</code></pre> <p>You can also explicitly set the resolution to <code>\"image\"</code> or <code>\"segmentation\"</code> to use the highest available resolution available for either. Resolution can also be specified in each of the functions for image or segmentation cutouts, but will default to the client values.</p> <p>Note that the volumetric data itself is not necessarily at the resolution specified, but rather this parameter determines how to interpret the coordinates. The resolution is set by the image and segmentation mip levels, which can be added either when creating the ImageryClient instance or when doing any cutout download. By default, ImageryClient will use the highest resolution mip level that is not labeled as a <code>\"placeholder\"</code> in CloudVolume.</p>"},{"location":"images/#specifying-image-size-instead-of-field-of-view","title":"Specifying image size instead of field of view","text":"<p>When upper and lower bounds are specified or a <code>bbox_size</code> is used, the resolution will change with mip level but the field of view that is downloaded will remain the same. Alternatively, one might want to download an image with a specific size in pixels and a specific mip level without having to calculate what bounding box would get you that.. This can be done in <code>image_cutout</code> by specifying the center point in the place of bounds and also specify <code>image_size</code> as a 2- or 3-element array. In this case, the center point will be adjusted according to the resolutions specified, while the field of view will change with image size.</p> <p>In practice, this only is needed for non-default mip levels.  If you specify mip level, this approach will always yield an image with the same size while a bounds-based approach will get smaller with increasing mips as the effective resolution gets coarser.</p> <p>For example, using bounds:</p> <pre><code>image = img_client.image_cutout(bounds, mip=3)\nImage.fromarray(image.T)\n</code></pre> <p>Figure 2: Imagery at MIP 3 resolution within specific bounds</p> <p>And using specified pixel dimensions:</p> <pre><code>img_size=(400, 400)\nimage = img_client.image_cutout(ctr, mip=3, image_size=img_size)\nImage.fromarray(image.T)\n</code></pre> <p>Figure 3: Imagery at MIP 3 with the specified image size</p> <p>You can also use the <code>scale_to_bounds=True</code> argument to upscale an image to the size specified in the bounding box, equivalent to having one pixel for each voxel as measured by the resolution parameter.</p>"},{"location":"images/#segmentations","title":"Segmentations","text":"<p>An aligned segmentation cutout is retrieved similarly. Note that segmentations show segment ids, and are not directly visualizable. However, in this case we can convert to a uint8 greyscale and see the gist, although there are many better approaches to coloring segmentations that will be shown later. Note that for dynamic segmentations, you can use the timestamp parameter to (optionally) set the time at which segmentation will e looked up.</p> <pre><code>seg = img_client.segmentation_cutout(bounds)\n\nimport numpy as np\nImage.fromarray( (seg.T / np.max(seg) * 255).astype('uint8') )\n</code></pre> <p>Figure 4: Segmentation of all objects within bounds</p> <p>Specific root ids can also be specified. All pixels outside those root ids have a value of 0.</p> <pre><code>root_ids = [2282, 4845]\nseg = img_client.segmentation_cutout(bounds, root_ids=root_ids)\nImage.fromarray( (seg.T / np.max(seg) * 255).astype('uint8') )\n</code></pre> <p>Figure 5: segmentation of specific objects within bounds</p>"},{"location":"images/#split-segmentations","title":"Split segmentations","text":"<p>It's often convenient to split out the segmentation for each root id as a distinct mask. These \"split segmentations\" come back as a dictionary with root id as key and binary mask as value.</p> <pre><code>split_seg = img_client.split_segmentation_cutout(bounds, root_ids=root_ids)\n\nImage.fromarray((split_seg[ root_ids[0] ].T * 255).astype('uint8'))\n</code></pre> <p>Figure 6: A single object's segmentation mask from the dictionary of segmentation masks.</p>"},{"location":"images/#aligned-cutouts","title":"Aligned cutouts","text":"<p>Aligned image and segmentations can be downloaded in one call, as well. If the lowest mip data in each differs in resolution, the lower resolution data will be optionally upsampled to the higher resolution in order to produce aligned overlays. Root ids and split segmentations can be optionally specified. This is the best option if your primary goal is overlay images.</p> <pre><code>image, segs = img_client.image_and_segmentation_cutout(bounds,\n                                                       split_segmentations=True,\n                                                       root_ids=root_ids)\n</code></pre> <p>Note that <code>image_size</code> is not an option for joint image and segmentation calls, because it's not clear which bounds to use. If this is needed, you can use the <code>img_client.segmentation_bbox_size_from_dimensions</code> or <code>img_client.image_bbox_size_from_dimensions</code> to get the appropriate <code>bbox_size</code> argument for a segmentation-based image dimension (or image-based, respectively).</p>"},{"location":"images/#using-with-caveclient","title":"Using with CAVEclient","text":"<p>While the ImageryClient was designed to work specifically with the CAVEclient and its associated suite of services, it should work with any cloudvolume project.</p> <p>However, if you are working within an CAVEclient-compatible project, a CAVEclient can be used to help configure the ImageryClient, filling in the imagery source, the segmentation source, authentication information, and the default resolution used in Neuroglancer.</p> <p>For example, we can download the data around this view of the MICRoNs mouse visual cortex data from Neuroglancer.</p> <pre><code>from caveclient import CAVEclient\nclient = CAVEclient('minnie65_public') .  # Note that you have to set up a token for this to work, see below.\n\nimg_client = ic.ImageryClient(client=client)\n\nctr = [240640, 207872, 21360]\n\nimage, segs = img_client.image_and_segmentation_cutout(ctr,\n                                                       split_segmentations=True,\n                                                       bbox_size=(1024, 1024),\n                                                       scale_to_bounds=True,\n)\n\nic.composite_overlay(segs, imagery=image, palette='husl')\n</code></pre> <p>Figure 7: Example segmentation cutout from the MICrONs dataset</p> <p>Note that the following code requires setting up a CAVE token to access the server. See here for details.</p>"},{"location":"overlays/","title":"Making Overlays","text":"<p>Once you have imagery and segmentation data, one important use case is to make visualizations overlaying segmentations on top of images.</p> <p>Now let produce an overlay of segmentation and imagery to highlight a particular synapse. Overlays are returned as a PIL Image, which has convenient saving options but can also be converted to RGBa (a is for \"alpha\", i.e. transparency) via a simple <code>np.array</code> call. Note that if imagery isn't specified, the segmentations are colored but not put over another image. Segmentations must be either a list or a dict, such as comes out of split segmentation cutouts.</p> <pre><code>ic.composite_overlay(segs, imagery=image)\n</code></pre> <p>Figure 1: Segmentation overlay with default colors</p>"},{"location":"overlays/#aesthetic-options","title":"Aesthetic options","text":"<p>Colors are chosen by default from the perceptually uniform discrete HUSL Palette as implemented in Seaborn, and any color scheme available through Seaborn's color_palette function is similarly easy to specify. Alpha is similarly easy to set.</p> <pre><code>ic.composite_overlay(segs, imagery=image, palette='tab10', alpha=0.4)\n</code></pre> <p>Figure 2: Segmentation overlay with specified color palette</p> <p>Colors can also be specified in the same form as the segmentations, e.g. a dictionary of root id to RGB tuple.</p> <pre><code>colors = {2282: (0,1,1), # cyan\n          4845: (1,0,0)} # red\nic.composite_overlay(segs, imagery=image, colors=colors)\n</code></pre> <p>Figure 3: Segmentation overlay with specified mapping between object id and color</p>"},{"location":"overlays/#outline-options","title":"Outline options","text":"<p>While the overlay guides the eye, it can also obscure the imagery. Because of that, one can also use highly configurable outlines instead of solid overlays. The default option puts the outlines along the outside of the segmentations, but omits lines where two segmentations touch.</p> <pre><code>ic.composite_overlay(segs, imagery=image, outline=True, alpha=0.5, width=15, colors=colors)\n</code></pre> <p>Figure 4: Segmentation overlay using outlines instead of filled regions</p> <p>Outlines can also be put inside of the segmentation and width can be specified. Additionally, setting <code>merge_outline</code> to False will not omit outlines in places where segmentations touch. Lots of different effects are possible!</p> <pre><code>ic.composite_overlay(segs,\n                     imagery=image,\n                     outline=True,\n                     alpha=1,\n                     width=3,\n                     merge_outline=False,\n                     side='in',\n                     colors=colors)\n</code></pre> <p>Figure 5: Segmentation overlay using distinct (unmerged) outlines</p>"},{"location":"overlays/#3d-image-stacks","title":"3d Image Stacks","text":"<p>All of the functions are designed to also work for 3d image stacks. Image and segmentation cutouts will return 3d arrays instead of 2d ones. However, note that composite images will come back as a list of PIL images. An optional <code>dim</code> argument will perform the slicing on axes other than the z-axis, although anisotropy in voxel resolution will not be accounted for.</p> <pre><code>ctr = [5019, 8677, 1211]\nwidth = 100\nz_slices = 3\n\nbounds_3d = ic.bounds_from_center(ctr, delx=width, dely=width, delz=z_slices)\n\nimage, segs = img_client.image_and_segmentation_cutout(bounds_3d, split_segmentations=True)\n\noverlays = ic.composite_overlay(segs, imagery=image, alpha=0.3, width=3,\n                                merge_outline=False, side='in')\n\noverlays[0]\n</code></pre> <p>Figure 6: One element of a series of stacked images</p> <p>In order to quickly assemble sequential images into a series, we can stack them. A <code>direction</code> argument will let you specify <code>vertical</code> instead of the default, and spacing can be adjusted as well.</p> <pre><code>ic.stack_images(overlays)\n</code></pre> <p>Figure 7: Series of cutouts from consecutive z-sections</p>"},{"location":"reference/composite_overlays/","title":"Composite Overlays","text":"<p>Overlay generation functions</p>"},{"location":"reference/composite_overlays/#imageryclient.composite.composite_overlay","title":"<code>composite_overlay(segs, colors=None, alpha=0.2, imagery=None, outline=False, merge_outline=True, overlap=True, width=10, side='out', dim=2, palette=DEFAULT_PALETTE, h=DEFAULT_H, l=DEFAULT_L, s=DEFAULT_S)</code>","text":"<p>Make a colored composite overlay for a 3d mask from an iterable of masks.</p> <p>Parameters:</p> Name Type Description Default <code>segs</code> <p>Iterable of masked images of the same size. If a dict, colors must be a dict as well.</p> required <code>colors</code> <code>list-like, dict, or None</code> <p>Iterable of RGB colors of the same size as masks. If a dict, masks must also be a dict and colors must have all keys in masks. If None, uses <code>discrete_colors</code> to generate colors.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha value for the overlay</p> <code>0.2</code> <code>imagery</code> <code>Image or None</code> <p>If an Image, applies the overlay to the image, by default None</p> <code>None</code> <code>outline</code> <code>bool</code> <p>If True, produces an outline instead of a flat overay, by default False</p> <code>False</code> <code>merge_outline</code> <code>bool</code> <p>If True, the merge outline applies to the segmentation as a whole and thus internal contacts are not outlined.</p> <code>True</code> <code>overlap</code> <code>bool</code> <p>If False, segmentations later in the list will not overlap segmentations earlier on the list.</p> <code>True</code> <code>width</code> <code>int</code> <p>If outline=True, sets the width of the outline, by default 10</p> <code>10</code> <code>side</code> <code>out or 'in'</code> <p>If outline=True, selects if the outline is inside or outside the original segmentation mask, by default 'out'</p> <code>'out'</code> <code>dim</code> <code>int</code> <p>Determines axis over which slices are iterated if the data is 3 dimensional. Default is 2 (z-axis).</p> <code>2</code> <p>Returns:</p> Type Description <code>list or Image</code> <p>Image or list of composite overlay images, optionally overlaid over provided imagery. List or single image is determined based on segmentation arrays being 2 or 3 dimensional.</p>"},{"location":"reference/composite_overlays/#imageryclient.composite.discrete_colors","title":"<code>discrete_colors(segs, palette=DEFAULT_PALETTE, h=DEFAULT_H, l=DEFAULT_L, s=DEFAULT_S)</code>","text":"<p>Generate discrete colors for segmentations from a palette generator. Defaults to perceptually uniform differences with high saturation.</p> <p>Parameters:</p> Name Type Description Default <code>segs</code> <code>list or dict</code> <p>Dict or list of segmentations to provide colors for.</p> required <code>palette</code> <code>'husl', 'hls', or str</code> <p>Which palette system to use, by default 'husl'. Will accept anything allowed by seaborn color_palette function.</p> <code>DEFAULT_PALETTE</code> <code>h</code> <code>float</code> <p>Hue value if husl or hls palettes are used, by default 0.01</p> <code>DEFAULT_H</code> <code>l</code> <code>float</code> <p>Lightness if husl or hls palettes are used, by default 0.6</p> <code>DEFAULT_L</code> <code>s</code> <code>int</code> <p>Saturation if husl or hls palettes are used, by default 1</p> <code>DEFAULT_S</code> <p>Returns:</p> Type Description <code>List or dict</code> <p>List or dict with one color per segmentation.</p>"},{"location":"reference/composite_overlays/#imageryclient.composite.stack_images","title":"<code>stack_images(images, direction='horizontal', spacing=10)</code>","text":"<p>Stack an iterable of images either veritcally or horizontally</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list - like</code> <p>Iterable of Image.Image objects</p> required <code>spacing</code> <code>int</code> <p>Spacing between images in pixels, by default 10</p> <code>10</code> <code>direction</code> <code>horizontal or vertical</code> <p>Direction of the grid of images, by default 'horizontal'</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>Image</code> <p>Combined grid of images</p>"},{"location":"reference/imagery_client/","title":"Imagery Client","text":"<p>Basic imagery client features</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient","title":"<code>ImageryClient(client=None, resolution=None, segmentation=True, imagery=True, image_source=None, segmentation_source=None, image_mip=None, segmentation_mip=None, auth_token=None, timestamp=None)</code>","text":"<p>             Bases: <code>object</code></p> <p>Tool to help download imagery and segmentation data.</p> <p>Can either take explicit cloudvolume paths for imagery and segmentation or use the Info Service to look up the right paths.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>CAVEclient or None</code> <p>A pre-initialized CAVEclient to use for configuration and authentication. If used, image source, segmentation source, and resolution come from the info service values.</p> <code>None</code> <code>resolution</code> <code>array - like or image or segmentation</code> <p>Sets the voxel resolution that bounds will be entered in, by default 'image', which is the mip 0 resolution of the imagery. Note that if a client is used to set the sources, the resolution will be set to the client default.</p> <code>None</code> <code>segmentation</code> <code>bool</code> <p>If False, no segmentation cloudvolume is initialized. By default True</p> <code>True</code> <code>imagery</code> <code>bool</code> <p>If False, no imagery cloudvolume is initialized. By default True</p> <code>True</code> <code>image_source</code> <code>str</code> <p>CloudVolume path to an imagery source, by default None</p> <code>None</code> <code>segmentation_source</code> <code>str</code> <p>CloudVolume path to a segmentation source, by default None</p> <code>None</code> <code>image_mip</code> <code>int</code> <p>Default mip level to use for imagery lookups, by default 0. Note that the same mip level for imagery and segmentation can correspond to different voxel resolutions.</p> <code>None</code> <code>segmentation_mip</code> <code>int</code> <p>Default mip level to use for segmentation lookups, by default 0.</p> <code>None</code> <code>auth_token</code> <code>str or None</code> <p>Auth token to use for cloudvolume. If None, uses the default values from the CAVEclient. Default is None.</p> <code>None</code> <code>timestamp</code> <code>(datetime or None)</code> <p>Fixed timestamp to use for segmentation lookups. If None, defaults to the present time when each function is run. Default is None.</p> <code>None</code>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.image_cv","title":"<code>image_cv</code>  <code>property</code>","text":"<p>Imagery CloudVolume</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.image_source","title":"<code>image_source</code>  <code>property</code>","text":"<p>Image cloudpath</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.resolution","title":"<code>resolution</code>  <code>property</code>","text":"<p>The voxel resolution assumed when locations are used for the client.</p> <p>Returns:</p> Type Description <code>list</code> <p>X, y, and z voxel resolution.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.segmentation_cv","title":"<code>segmentation_cv</code>  <code>property</code>","text":"<p>Segmentation CloudVolume object</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.segmentation_source","title":"<code>segmentation_source</code>  <code>property</code>","text":"<p>Segmentation cloudpath</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.image_and_segmentation_cutout","title":"<code>image_and_segmentation_cutout(bounds, image_mip=None, segmentation_mip=None, root_ids='all', resize=True, split_segmentations=False, include_null_root=False, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)</code>","text":"<p>Download aligned and scaled imagery and segmentation data at a given resolution.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>2x3 list of ints</code> <p>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.</p> required <code>image_mip</code> <code>int</code> <p>Mip level of the imagery if something other than the default is wanted, by default None</p> <code>None</code> <code>segmentation_mip</code> <code>int</code> <p>Mip level of the segmentation if something other than the default is wanted, by default None</p> <code>None</code> <code>root_ids</code> <code>list, None, or 'all'</code> <p>If a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If 'all', finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default 'all'.</p> <code>'all'</code> <code>resize</code> <code>bool</code> <p>If True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).</p> <code>True</code> <code>split_segmentations</code> <code>bool</code> <p>If True, the segmentation is returned as a dict of masks (using split_segmentation_cutout), and if False returned as an array with root_ids (using segmentation_cutout), by default False</p> <code>False</code> <code>include_null_root</code> <code>bool</code> <p>If True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.</p> <code>False</code> <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</p> <code>None</code> <code>timestamp</code> <code>datetime or None</code> <p>Timestamp to use for dynamic segmentation data</p> <code>None</code> <code>scale_to_bounds</code> <code>bool or None</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code> <code>convert_to_int64</code> <code>bool</code> <p>If True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.</p> <code>True</code> <p>Returns:</p> Type Description <code>VolumeCutout</code> <p>Imagery volume cutout</p> <code>ndarray or dict</code> <p>Segmentation volume cutout as either an ndarray or dict of masks depending on the split_segmentations flag.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions","title":"<code>image_bbox_size_from_dimensions(image_size, mip=None, resolution=None)</code>","text":"<p>Get the bbox_size equivalent for an imagery cutout with specified pixel dimensions</p> <p>Parameters:</p> Name Type Description Default <code>image_size</code> <p>Image size in pixels (2-element) or voxels (3-element)</p> required <code>mip</code> <p>Mip for which the image would be computed. Defaults to None, which uses the client default.</p> <code>None</code> <code>resolution</code> <p>Resolution to use for the bbox_size. Defaults to None, or the client defauls.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Argument for bbox_size that would give the desired pixel dimensions.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.image_cutout","title":"<code>image_cutout(bounds, bbox_size=None, image_size=None, mip=None, resolution=None, scale_to_bounds=None)</code>","text":"<p>Get an image cutout for a certain location or set of bounds and a mip level.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>array</code> <p>Either a 2x3 array of a lower bound and upper bound point to bound the cutout in units of voxels in a resolution set by the base_resolution parameter. Alternatively, if bbox_size or image_size is set, bounds should be a 3-element array specifying the center of the field of view.</p> required <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.</p> <code>None</code> <code>image_size</code> <code>array or None</code> <p>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</p> <code>None</code> <code>mip</code> <code>int</code> <p>Mip level of imagery to get if something other than the default is wanted, by default None.</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</p> <code>None</code> <code>scale_to_bounds</code> <code>bool, optional.</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code> <p>Returns:</p> Type Description <code>    cloudvolume.VolumeCutout</code> <p>An n-d image of the image requested with image intensity values as the elements.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks","title":"<code>save_image_and_segmentation_masks(filename_prefix, bounds=None, image_mip=None, segmentation_mip=None, root_ids='all', include_null_root=False, segmentation_colormap={}, resize=True, precomputed_data=None, slice_axis=2, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, **kwargs)</code>","text":"<p>Save aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.</p> <p>Parameters:</p> Name Type Description Default <code>filename_prefix</code> <code>str</code> <p>Prefix for the segmentation filenames. The full filename will be either {filename_prefix}root_id.png or {filename_prefix}root_id.png, depending on if multiple slices of each root id are saved.}_{i</p> required <code>bounds</code> <code>2x3 list of ints</code> <p>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed data is not passed. By default, None.</p> <code>None</code> <code>image_mip</code> <code>int</code> <p>Only used if a precomputed data is not passed. Mip level of imagery to get if something other than the default is wanted, by default None.</p> <code>None</code> <code>segmentation_mip</code> <code>int</code> <p>Only used if precomputed data is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None</p> <code>None</code> <code>root_ids</code> <code>list, None, or 'all'</code> <p>If a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If 'all', finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default 'all'.</p> <code>'all'</code> <code>include_null_root</code> <code>bool</code> <p>If True, includes root id of 0, which is usually reserved for a null segmentation value. By default, False.</p> <code>False</code> <code>segmentation_colormap</code> <code>dict</code> <p>A dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.</p> <code>{}</code> <code>resize</code> <code>bool</code> <p>If True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).</p> <code>True</code> <code>precomputed_data</code> <code>tuple</code> <p>Already computed tuple with imagery and segmentation mask data, in that order. If not provided, bounds must be given to download cutout data. By default, None.</p> <code>None</code> <code>slice_axis</code> <code>int</code> <p>If the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)</p> <code>2</code> <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution of the bounds provided. If not provided, uses the client defaults.</p> <code>None</code> <code>timestamp</code> <code>datetime</code> <p>Timestamp to use for the segmentation. If not provided, defaults to the client defaults.</p> <code>None</code> <code>scale_to_bounds</code> <code>bool or None</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.save_imagery","title":"<code>save_imagery(filename_prefix, bounds=None, mip=None, precomputed_image=None, slice_axis=2, bbox_size=None, image_size=None, resolution=None, scale_to_bounds=None, verbose=False, **kwargs)</code>","text":"<p>Save queried or precomputed imagery to png files.</p> <p>Parameters:</p> Name Type Description Default <code>filename_prefix</code> <code>str</code> <p>Prefix for the imagery filename. The full filename will be {filename_prefix}_imagery.png</p> required <code>bounds</code> <code>2x3 list of ints</code> <p>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed image is not passed. By default, None.</p> <code>None</code> <code>mip</code> <code>int</code> <p>Only used if a precomputed image is not passed. Mip level of imagery to get if something other than the default is wanted, by default None</p> <code>None</code> <code>precomputed_image</code> <code>VolumeCutout</code> <p>Already downloaded VolumeCutout data to save explicitly. If called this way, the bounds and mip arguments will not apply. If a precomputed image is not provided, bounds must be specified to download the cutout data. By default None</p> <code>None</code> <code>slice_axis</code> <code>int</code> <p>If the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)</p> <code>2</code> <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</p> <code>None</code> <code>image_size</code> <code>array or None</code> <p>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</p> <code>None</code> <code>scale_to_bounds</code> <code>bool or None</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, prints the progress, by default False</p> <code>False</code>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.save_segmentation_masks","title":"<code>save_segmentation_masks(filename_prefix, bounds=None, mip=None, root_ids='all', precomputed_masks=None, segmentation_colormap={}, slice_axis=2, include_null_root=False, bbox_size=None, image_size=None, resolution=None, timestamp=None, scale_to_bounds=None, verbose=False, **kwargs)</code>","text":"<p>Save queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.</p> <p>Parameters:</p> Name Type Description Default <code>filename_prefix</code> <code>str</code> <p>Prefix for the segmentation filenames. The full filename will be either {filename_prefix}root_id.png or {filename_prefix}root_id.png, depending on if multiple slices of each root id are saved.}_{i</p> required <code>bounds</code> <code>2x3 list of ints</code> <p>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution specified. Only used if a precomputed segmentation is not passed. By default, None.</p> <code>None</code> <code>mip</code> <code>int</code> <p>Only used if a precomputed segmentation is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None</p> <code>None</code> <code>root_ids</code> <code>list, None, or 'all'</code> <p>If a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If 'all', finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default 'all'.</p> <code>'all'</code> <code>precomputed_masks</code> <code>dict</code> <p>Already downloaded dict of mask data to save explicitly. If called this way, the bounds and mip arguments will not apply. If precomputed_masks are not provided, bounds must be given to download cutout data. By default None</p> <code>None</code> <code>segmentation_colormap</code> <code>dict</code> <p>A dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.</p> <code>{}</code> <code>slice_axis</code> <code>int</code> <p>If the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)</p> <code>2</code> <code>include_null_root</code> <code>bool</code> <p>If True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.</p> <code>False</code> <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</p> <code>None</code> <code>image_size</code> <code>array or None</code> <p>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</p> <code>None</code> <code>timestamp</code> <code>datetime or None</code> <p>Timestamp to use for dynamic segmentation data</p> <code>None</code> <code>scale_to_bounds</code> <code>bool or None</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions","title":"<code>segmentation_bbox_size_from_dimensions(image_size, mip=None, resolution=None)</code>","text":"<p>Get the bbox_size equivalent for an segmentation cutout with specified pixel dimensions</p> <p>Parameters:</p> Name Type Description Default <code>image_size</code> <p>Image size in pixels (2-element) or voxels (3-element)</p> required <code>mip</code> <p>Mip for which the image would be computed. Defaults to None, which uses the client default.</p> <code>None</code> <code>resolution</code> <p>Resolution to use for the bbox_size. Defaults to None, or the client defauls.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Argument for bbox_size that would give the desired pixel dimensions.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.segmentation_cutout","title":"<code>segmentation_cutout(bounds, root_ids='all', bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)</code>","text":"<p>Get a cutout of the segmentation imagery for some or all root ids between set bounds. Note that if all root ids are requested in a large region, it could take a long time to query all supervoxels.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>2x3 list of ints</code> <p>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.</p> required <code>root_ids</code> <code>list, None, or 'all'</code> <p>If a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If 'all', find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default 'all'</p> <code>'all'</code> <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.</p> <code>None</code> <code>image_size</code> <code>array or None</code> <p>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</p> <code>None</code> <code>mip</code> <code>int</code> <p>Mip level of the segmentation if something other than the defualt is wanted, by default None</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</p> <code>None</code> <code>timestamp</code> <code>datetime or None</code> <p>Timestamp to use for dynamic segmentation data</p> <code>None</code> <code>scale_to_bounds</code> <code>bool or None</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code> <code>convert_to_int64</code> <code>bool</code> <p>If True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array whose elements correspond to the root id (or, if root_ids=None, the supervoxel id) at each voxel.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.ImageryClient.split_segmentation_cutout","title":"<code>split_segmentation_cutout(bounds, root_ids='all', include_null_root=False, bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None)</code>","text":"<p>Generate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>2x3 list of ints</code> <p>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.</p> required <code>root_ids</code> <code>list, None, or 'all'</code> <p>If a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If 'all', find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default 'all'</p> <code>'all'</code> <code>include_null_root</code> <code>bool</code> <p>If True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.</p> <code>False</code> <code>bbox_size</code> <code>array or None</code> <p>If not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.</p> <code>None</code> <code>image_size</code> <code>array or None</code> <p>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</p> <code>None</code> <code>mip</code> <code>int</code> <p>Mip level of the segmentation if something other than the default is wanted, by default None</p> <code>None</code> <code>resolution</code> <code>list - like</code> <p>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</p> <code>None</code> <code>timestamp</code> <code>datetime or None</code> <p>Timestamp to use for dynamic segmentation data</p> <code>None</code> <code>scale_to_bounds</code> <code>bool or None</code> <p>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dict whose keys are root ids and whose values are the binary mask for that root id, with a 1 where the object contains the voxel.</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.bounds_from_center","title":"<code>bounds_from_center(ctr, width=1, height=1, depth=1)</code>","text":"<p>Generate bounds from a center point and dimensions for each direction</p> <p>Parameters:</p> Name Type Description Default <code>ctr</code> <code>array - like</code> <p>x,y,z coordinates of the center of the bounds in voxel dimensions.</p> required <code>width</code> <p>Width of the box in the x direction in. Default is 1.</p> <code>1</code> <code>height</code> <p>Height of the box in the y direction. Default is 1.</p> <code>1</code> <code>depth</code> <p>Depth of the box in the z direction. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>array</code> <p>2x3 array of lower and upper bounds (in that order).</p>"},{"location":"reference/imagery_client/#imageryclient.imagery.save_image_slices","title":"<code>save_image_slices(filename_prefix, filename_suffix, img, slice_axis, image_type, verbose=False, color=None, **kwargs)</code>","text":"<p>Helper function for generic image saving</p>"}]}