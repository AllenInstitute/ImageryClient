[
  {
    "objectID": "reference/utils.rescale_to_bounds.html",
    "href": "reference/utils.rescale_to_bounds.html",
    "title": "utils.rescale_to_bounds",
    "section": "",
    "text": "utils.rescale_to_bounds\nutils.rescale_to_bounds(img, bbox)"
  },
  {
    "objectID": "reference/imagery.save_image_slices.html",
    "href": "reference/imagery.save_image_slices.html",
    "title": "imagery.save_image_slices",
    "section": "",
    "text": "imagery.save_image_slices\nimagery.save_image_slices(filename_prefix, filename_suffix, img, slice_axis, image_type, verbose=False, color=None, **kwargs)\nHelper function for generic image saving"
  },
  {
    "objectID": "reference/composite.stack_images.html",
    "href": "reference/composite.stack_images.html",
    "title": "composite.stack_images",
    "section": "",
    "text": "composite.stack_images(images, direction='horizontal', spacing=10)\nStack an iterable of images either veritcally or horizontally\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nimages\nlist - like\nIterable of Image.Image objects\nrequired\n\n\nspacing\nint\nSpacing between images in pixels, by default 10\n10\n\n\ndirection\nhorizontal or vertical\nDirection of the grid of images, by default ‘horizontal’\n'horizontal'\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPIL.Image.PIL.Image.Image\nCombined grid of images"
  },
  {
    "objectID": "reference/composite.stack_images.html#parameters",
    "href": "reference/composite.stack_images.html#parameters",
    "title": "composite.stack_images",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nimages\nlist - like\nIterable of Image.Image objects\nrequired\n\n\nspacing\nint\nSpacing between images in pixels, by default 10\n10\n\n\ndirection\nhorizontal or vertical\nDirection of the grid of images, by default ‘horizontal’\n'horizontal'"
  },
  {
    "objectID": "reference/composite.stack_images.html#returns",
    "href": "reference/composite.stack_images.html#returns",
    "title": "composite.stack_images",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nPIL.Image.PIL.Image.Image\nCombined grid of images"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function Reference",
    "section": "",
    "text": "This site provides basic documentation for the functions in ImageryClient. Please see the tutorials for more information about how to use them.\nDocumentation is split into three parts:\n\nImageryClient for using the ImageryClient class to download images and segmentation.\nCompositing for generating segmentation overlays for visualization.\nUtilities has additional utilities that may be useful for data manipulation. Note that, unlike the other two categories, these functions are not imported by default."
  },
  {
    "objectID": "reference/index.html#imageryclient",
    "href": "reference/index.html#imageryclient",
    "title": "Function Reference",
    "section": "ImageryClient",
    "text": "ImageryClient\nMain functions for downloading imagery and segmentation data.\n\n\n\nimagery.bounds_from_center\nGenerate bounds from a center point and dimensions for each direction\n\n\nimagery.ImageryClient\nTool to help download imagery and segmentation data."
  },
  {
    "objectID": "reference/index.html#compositing",
    "href": "reference/index.html#compositing",
    "title": "Function Reference",
    "section": "Compositing",
    "text": "Compositing\nFunctions for generating overlay visualizations of images and segmentation.\n\n\n\ncomposite.stack_images\nStack an iterable of images either veritcally or horizontally\n\n\ncomposite.composite_overlay\nMake a colored composite overlay for a 3d mask from an iterable of masks."
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Function Reference",
    "section": "Utilities",
    "text": "Utilities\nAdditional utility functions for working with imagery and segmentation data.\n\n\n\nutils.rescale_to_bounds\n\n\n\nutils.binary_seg_outline\nConvert a 2d image segmentation to a binary outline inside or outside the segmentation\n\n\nutils.mask_image\nApply mask as a a transparency layer to seg\n\n\nutils.segmentation_masks\nConvert a segmentation array into a dict of binary masks for each root id."
  },
  {
    "objectID": "reference/utils.mask_image.html",
    "href": "reference/utils.mask_image.html",
    "title": "utils.mask_image",
    "section": "",
    "text": "utils.mask_image(seg, mask)\nApply mask as a a transparency layer to seg\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nseg\nPIL.Image.PIL.Image.Image\nRGBa image.\nrequired\n\n\nmask\nnumpy.numpy.ndarray\nMask with the same number of pixels as the RGBa image. Note that the mask is transposed relative to the image pixels.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPIL.Image.PIL.Image.Image\nOriginal segmentation with the mask values set be fully transparent."
  },
  {
    "objectID": "reference/utils.mask_image.html#parameters",
    "href": "reference/utils.mask_image.html#parameters",
    "title": "utils.mask_image",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nseg\nPIL.Image.PIL.Image.Image\nRGBa image.\nrequired\n\n\nmask\nnumpy.numpy.ndarray\nMask with the same number of pixels as the RGBa image. Note that the mask is transposed relative to the image pixels.\nrequired"
  },
  {
    "objectID": "reference/utils.mask_image.html#returns",
    "href": "reference/utils.mask_image.html#returns",
    "title": "utils.mask_image",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nPIL.Image.PIL.Image.Image\nOriginal segmentation with the mask values set be fully transparent."
  },
  {
    "objectID": "reference/imagery.bounds_from_center.html",
    "href": "reference/imagery.bounds_from_center.html",
    "title": "imagery.bounds_from_center",
    "section": "",
    "text": "imagery.bounds_from_center(ctr, width=1, height=1, depth=1)\nGenerate bounds from a center point and dimensions for each direction\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nctr\narray - like\nx,y,z coordinates of the center of the bounds in voxel dimensions.\nrequired\n\n\nwidth\n\nWidth of the box in the x direction in. Default is 1.\n1\n\n\nheight\n\nHeight of the box in the y direction. Default is 1.\n1\n\n\ndepth\n\nDepth of the box in the z direction. Default is 1.\n1\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\narray\n2x3 array of lower and upper bounds (in that order)."
  },
  {
    "objectID": "reference/imagery.bounds_from_center.html#parameters",
    "href": "reference/imagery.bounds_from_center.html#parameters",
    "title": "imagery.bounds_from_center",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nctr\narray - like\nx,y,z coordinates of the center of the bounds in voxel dimensions.\nrequired\n\n\nwidth\n\nWidth of the box in the x direction in. Default is 1.\n1\n\n\nheight\n\nHeight of the box in the y direction. Default is 1.\n1\n\n\ndepth\n\nDepth of the box in the z direction. Default is 1.\n1"
  },
  {
    "objectID": "reference/imagery.bounds_from_center.html#returns",
    "href": "reference/imagery.bounds_from_center.html#returns",
    "title": "imagery.bounds_from_center",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\narray\n2x3 array of lower and upper bounds (in that order)."
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "ImageryClient helps with both downloading aligned images and segmentations and turning these into overlays."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ImageryClient",
    "section": "",
    "text": "Connectomics data often involves a combination of microscopy imagery and segmentation, labels of distinct objects applied to this imagery. While exploring the data in tools like Neuroglancer is great, a common task is often to make figures overlaying 2d images and segmentation sliced from the larger data. ImageryClient is designed to make it easy to generate aligned cutouts from imagery and segmentation, and make it efficient to produce attractive, publication-ready overlay images.\nBecause of the size of these volumes, cloud-based serverless n-d array file storage systems are often used to host this data. CloudVolume has become an excellent general purpose tool for accessing such data. However, imagery and segmentation for the same data are hosted at distinct cloud locations and can differ in basic properties like base resolution. Moreover, imagery and segmentation have data that means intrensically different things. Values in imagery indicate pixel intensity in order to produce a picture, while values in segmentation indicate the object id at a given location. ImageryClient acts as a front end for making aligned cutouts from multiple cloudvolume sources, splitting segmentations into masks for each object, and more."
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "We make use of Numpy arrays and Pillow Images to represent data. Both are extremely rich tools, and to learn more about them please see the appropriate documentation for information about saving data to image files and more."
  },
  {
    "objectID": "getting_started.html#installation",
    "href": "getting_started.html#installation",
    "title": "Getting Started",
    "section": "Installation",
    "text": "Installation\nImageryClient can be installed with pip:\npip install imageryclient\nWhile not required, if you are using a CAVE-hosted dataset, installing CAVEclient will make your life much easier.\n\n\n\n\n\n\nTroubleshooting\n\n\n\nIf you have installation issues due to Cloudvolume, which can have a complex set of requirements, we recommend looking at its github issues page for help."
  },
  {
    "objectID": "getting_started.html#basic-example",
    "href": "getting_started.html#basic-example",
    "title": "Getting Started",
    "section": "Basic example",
    "text": "Basic example\nA small example that uses all of the major components of ImageryClient: Downloading aligned images and segmentation, specifying specific segmentations to visualize, and generating an image overlay. This uses the pubically available Kasthuri et al. 2014 dataset.\nimport imageryclient as ic\n\nimg_src = 'precomputed://gs://neuroglancer-public-data/kasthuri2011/image_color_corrected'\nseg_src = 'precomputed://gs://neuroglancer-public-data/kasthuri2011/ground_truth'\n\nimg_client = ic.ImageryClient(image_source=img_src, segmentation_source=seg_src)\n\nbounds = [\n    [5119, 8477, 1201],\n    [5519, 8877, 1202]\n]\nroot_ids = [2282, 4845]\n\nimage, segs = img_client.image_and_segmentation_cutout(bounds,\n                                                       split_segmentations=True,\n                                                       root_ids=root_ids)\n\n\nic.composite_overlay(segs, imagery=image)\n\n\n\noverlay 0"
  },
  {
    "objectID": "tutorials/overlays.html",
    "href": "tutorials/overlays.html",
    "title": "Making Overlays",
    "section": "",
    "text": "Once you have imagery and segmentation data, one important use case is to make visualizations overlaying segmentations on top of images.\nNow let produce an overlay of segmentation and imagery to highlight a particular synapse. Overlays are returned as a PIL Image, which has convenient saving options but can also be converted to RGBa (a is for “alpha”, i.e. transparency) via a simple np.array call. Note that if imagery isn’t specified, the segmentations are colored but not put over another image. Segmentations must be either a list or a dict, such as comes out of split segmentation cutouts."
  },
  {
    "objectID": "tutorials/overlays.html#d-image-stacks",
    "href": "tutorials/overlays.html#d-image-stacks",
    "title": "Making Overlays",
    "section": "3d Image Stacks",
    "text": "3d Image Stacks\nAll of the functions are designed to also work for 3d image stacks. Image and segmentation cutouts will return 3d arrays instead of 2d ones. However, note that composite images will come back as a list of PIL images. An optional dim argument will perform the slicing on axes other than the z-axis, although anisotropy in voxel resolution will not be accounted for.\nctr = [5019, 8677, 1211]\nwidth = 100\nz_slices = 3\n\nbounds_3d = ic.bounds_from_center(ctr, delx=width, dely=width, delz=z_slices)\n\nimage, segs = img_client.image_and_segmentation_cutout(bounds_3d, split_segmentations=True)\n\noverlays = ic.composite_overlay(segs, imagery=image, alpha=0.3, width=3,\n                                merge_outline=False, side='in')\n\noverlays[0]\n\n\n\nSeries 0\n\n\nIn order to quickly assemble sequential images into a series, we can stack them. A direction argument will let you specify vertical instead of the default, and spacing can be adjusted as well.\nic.stack_images(overlays)\n\n\n\nSeries 1"
  },
  {
    "objectID": "tutorials/images.html",
    "href": "tutorials/images.html",
    "title": "Using ImageryClient",
    "section": "",
    "text": "Here, we will use the ImageryClient to get some data from the Kasthuri et al. 2014 dataset hosted by Google. In its simplest form, we just intialize an ImageryClient object with an image cloudpath and a segmentation cloudpath. Values are taken from the layers in the linked neuroglancer state."
  },
  {
    "objectID": "tutorials/images.html#using-with-caveclient",
    "href": "tutorials/images.html#using-with-caveclient",
    "title": "Using ImageryClient",
    "section": "Using with CAVEclient",
    "text": "Using with CAVEclient\nWhile the ImageryClient was designed to work specifically with the CAVEclient and its associated suite of services, it should work with any cloudvolume project.\nHowever, if you are working within an CAVEclient-compatible project, a CAVEclient can be used to help configure the ImageryClient, filling in the imagery source, the segmentation source, authentication information, and the default resolution used in Neuroglancer.\nFor example, we can download the data around this view of the MICRoNs mouse visual cortex data from Neuroglancer.\nfrom caveclient import CAVEclient\nclient = CAVEclient('minnie65_public') .  # Note that you have to set up a token for this to work, see below.\n\nimg_client = ic.ImageryClient(client=client)\n\nctr = [240640, 207872, 21360]\n\nimage, segs = img_client.image_and_segmentation_cutout(ctr,\n                                                       split_segmentations=True,\n                                                       bbox_size=(1024, 1024),\n                                                       scale_to_bounds=True,\n)\n\nic.composite_overlay(segs, imagery=image, palette='husl')\n\n\n\nMicrons Example\n\n\nNote that the following code requires setting up a CAVE token to access the server. See here for details."
  },
  {
    "objectID": "reference/utils.binary_seg_outline.html",
    "href": "reference/utils.binary_seg_outline.html",
    "title": "utils.binary_seg_outline",
    "section": "",
    "text": "utils.binary_seg_outline(seg, width, side='out', color=None, alpha=1)\nConvert a 2d image segmentation to a binary outline inside or outside the segmentation\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nseg\nPIL image or array\none-channel PIL Image or 2d array representing image values\nrequired\n\n\nwidth\nint\nWidth of outline in pixels\nrequired\n\n\nside\nout or ‘in’\nWhether outline is inside or outside the segmentation mask\n'out'\n\n\ncolor\nlist or None\nRGB color for masked values (0-255) or None for white.\nNone\n\n\nalpha\nfloat\n0-1 value for transparency.\n1\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPIL.PIL.Image.PIL.Image.Image\nImage with outline"
  },
  {
    "objectID": "reference/utils.binary_seg_outline.html#parameters",
    "href": "reference/utils.binary_seg_outline.html#parameters",
    "title": "utils.binary_seg_outline",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nseg\nPIL image or array\none-channel PIL Image or 2d array representing image values\nrequired\n\n\nwidth\nint\nWidth of outline in pixels\nrequired\n\n\nside\nout or ‘in’\nWhether outline is inside or outside the segmentation mask\n'out'\n\n\ncolor\nlist or None\nRGB color for masked values (0-255) or None for white.\nNone\n\n\nalpha\nfloat\n0-1 value for transparency.\n1"
  },
  {
    "objectID": "reference/utils.binary_seg_outline.html#returns",
    "href": "reference/utils.binary_seg_outline.html#returns",
    "title": "utils.binary_seg_outline",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nPIL.PIL.Image.PIL.Image.Image\nImage with outline"
  },
  {
    "objectID": "reference/utils.segmentation_masks.html",
    "href": "reference/utils.segmentation_masks.html",
    "title": "utils.segmentation_masks",
    "section": "",
    "text": "utils.segmentation_masks(seg_img, include_null_root=False)\nConvert a segmentation array into a dict of binary masks for each root id.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nseg_img\nnumpy.numpy.ndarray\nArray with voxel values corresponding to the object id at that voxel\nrequired\n\n\ninclude_null_root\nbool\nCreate a mask for 0 id, which usually denotes no object, by default False\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nDict of binary masks. Keys are root ids, values are boolean n-d arrays with a 1 where that object is."
  },
  {
    "objectID": "reference/utils.segmentation_masks.html#parameters",
    "href": "reference/utils.segmentation_masks.html#parameters",
    "title": "utils.segmentation_masks",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nseg_img\nnumpy.numpy.ndarray\nArray with voxel values corresponding to the object id at that voxel\nrequired\n\n\ninclude_null_root\nbool\nCreate a mask for 0 id, which usually denotes no object, by default False\nFalse"
  },
  {
    "objectID": "reference/utils.segmentation_masks.html#returns",
    "href": "reference/utils.segmentation_masks.html#returns",
    "title": "utils.segmentation_masks",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\ndict\nDict of binary masks. Keys are root ids, values are boolean n-d arrays with a 1 where that object is."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html",
    "href": "reference/imagery.ImageryClient.html",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient(self, client=None, resolution=None, segmentation=True, imagery=True, image_source=None, segmentation_source=None, image_mip=None, segmentation_mip=None, auth_token=None, timestamp=None)\nTool to help download imagery and segmentation data.\nCan either take explicit cloudvolume paths for imagery and segmentation or use the Info Service to look up the right paths.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclient\ncaveclient.caveclient.CAVEclient or None\nA pre-initialized CAVEclient to use for configuration. If used, the image source and segmentation source come from the info service values.\nNone\n\n\nresolution\narray - like or image or segmentation\nSets the voxel resolution that bounds will be entered in, by default ‘image’, which is the mip 0 resolution of the imagery.\nNone\n\n\nsegmentation\nbool\nIf False, no segmentation cloudvolume is initialized. By default True\nTrue\n\n\nimagery\nbool\nIf False, no imagery cloudvolume is initialized. By default True\nTrue\n\n\nimage_source\nstr\nCloudVolume path to an imagery source, by default None\nNone\n\n\nsegmentation_source\nstr\nCloudVolume path to a segmentation source, by default None\nNone\n\n\nimage_mip\nint\nDefault mip level to use for imagery lookups, by default 0. Note that the same mip level for imagery and segmentation can correspond to different voxel resolutions.\nNone\n\n\nsegmentation_mip\nint\nDefault mip level to use for segmentation lookups, by default 0.\nNone\n\n\nauth_token\nstr or None\nAuth token to use for cloudvolume. If None, uses the default values from the CAVEclient. Default is None.\nNone\n\n\ntimestamp\n(datetime.datetime.datetime or None)\nFixed timestamp to use for segmentation lookups. If None, defaults to the present time when each function is run. Default is None.\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nimage_cv\nImagery CloudVolume\n\n\nimage_source\nImage cloudpath\n\n\nresolution\nThe voxel resolution assumed when locations are used for the client.\n\n\nsegmentation_cv\nSegmentation CloudVolume object\n\n\nsegmentation_source\nSegmentation cloudpath\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nimage_and_segmentation_cutout\nDownload aligned and scaled imagery and segmentation data at a given resolution.\n\n\nimage_bbox_size_from_dimensions\nGet the bbox_size equivalent for an imagery cutout with specified pixel dimensions\n\n\nimage_cutout\nGet an image cutout for a certain location or set of bounds and a mip level.\n\n\nsave_image_and_segmentation_masks\nSave aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.\n\n\nsave_imagery\nSave queried or precomputed imagery to png files.\n\n\nsave_segmentation_masks\nSave queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.\n\n\nsegmentation_bbox_size_from_dimensions\nGet the bbox_size equivalent for an segmentation cutout with specified pixel dimensions\n\n\nsegmentation_cutout\nGet a cutout of the segmentation imagery for some or all root ids between set bounds.\n\n\nsplit_segmentation_cutout\nGenerate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values.\n\n\n\n\n\n\nimagery.ImageryClient.image_and_segmentation_cutout(bounds, image_mip=None, segmentation_mip=None, root_ids='all', resize=True, split_segmentations=False, include_null_root=False, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)\nDownload aligned and scaled imagery and segmentation data at a given resolution.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.\nrequired\n\n\nimage_mip\nint\nMip level of the imagery if something other than the default is wanted, by default None\nNone\n\n\nsegmentation_mip\nint\nMip level of the segmentation if something other than the default is wanted, by default None\nNone\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.\n'all'\n\n\nresize\nbool\nIf True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).\nTrue\n\n\nsplit_segmentations\nbool\nIf True, the segmentation is returned as a dict of masks (using split_segmentation_cutout), and if False returned as an array with root_ids (using segmentation_cutout), by default False\nFalse\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.\nFalse\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\nconvert_to_int64\nbool\nIf True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ncloudvolume.cloudvolume.VolumeCutout\nImagery volume cutout\n\n\nnumpy.numpy.ndarray or dict\nSegmentation volume cutout as either an ndarray or dict of masks depending on the split_segmentations flag.\n\n\n\n\n\n\n\nimagery.ImageryClient.image_bbox_size_from_dimensions(image_size, mip=None, resolution=None)\nGet the bbox_size equivalent for an imagery cutout with specified pixel dimensions\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nimage_size\n\nImage size in pixels (2-element) or voxels (3-element)\nrequired\n\n\nmip\n\nMip for which the image would be computed. Defaults to None, which uses the client default.\nNone\n\n\nresolution\n\nResolution to use for the bbox_size. Defaults to None, or the client defauls.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\n\nArgument for bbox_size that would give the desired pixel dimensions.\n\n\n\n\n\n\n\nimagery.ImageryClient.image_cutout(bounds, bbox_size=None, image_size=None, mip=None, resolution=None, scale_to_bounds=None)\nGet an image cutout for a certain location or set of bounds and a mip level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\narray\nEither a 2x3 array of a lower bound and upper bound point to bound the cutout in units of voxels in a resolution set by the base_resolution parameter. Alternatively, if bbox_size or image_size is set, bounds should be a 3-element array specifying the center of the field of view.\nrequired\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nmip\nint\nMip level of imagery to get if something other than the default is wanted, by default None.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\nscale_to_bounds\nbool, optional.\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ncloudvolume.VolumeCutout\nAn n-d image of the image requested with image intensity values as the elements.\n\n\n\n\n\n\n\nimagery.ImageryClient.save_image_and_segmentation_masks(filename_prefix, bounds=None, image_mip=None, segmentation_mip=None, root_ids='all', include_null_root=False, segmentation_colormap={}, resize=True, precomputed_data=None, slice_axis=2, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, **kwargs)\nSave aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename_prefix\nstr\nPrefix for the segmentation filenames. The full filename will be either {filename_prefix}root_id{root_id}.png or {filename_prefix}root_id{root_id}_{i}.png, depending on if multiple slices of each root id are saved.\nrequired\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed data is not passed. By default, None.\nNone\n\n\nimage_mip\nint\nOnly used if a precomputed data is not passed. Mip level of imagery to get if something other than the default is wanted, by default None.\nNone\n\n\nsegmentation_mip\nint\nOnly used if precomputed data is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None\nNone\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.\n'all'\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. By default, False.\nFalse\n\n\nsegmentation_colormap\ndict\nA dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.\n{}\n\n\nresize\nbool\nIf True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).\nTrue\n\n\nprecomputed_data\ntuple\nAlready computed tuple with imagery and segmentation mask data, in that order. If not provided, bounds must be given to download cutout data. By default, None.\nNone\n\n\nslice_axis\nint\nIf the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)\n2\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nresolution\nlist - like\nVoxel resolution of the bounds provided. If not provided, uses the client defaults.\nNone\n\n\ntimestamp\ndatetime\nTimestamp to use for the segmentation. If not provided, defaults to the client defaults.\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\n\n\n\n\n\nimagery.ImageryClient.save_imagery(filename_prefix, bounds=None, mip=None, precomputed_image=None, slice_axis=2, bbox_size=None, image_size=None, resolution=None, scale_to_bounds=None, verbose=False, **kwargs)\nSave queried or precomputed imagery to png files.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename_prefix\nstr\nPrefix for the imagery filename. The full filename will be {filename_prefix}_imagery.png\nrequired\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed image is not passed. By default, None.\nNone\n\n\nmip\nint\nOnly used if a precomputed image is not passed. Mip level of imagery to get if something other than the default is wanted, by default None\nNone\n\n\nprecomputed_image\ncloudvolume.cloudvolume.VolumeCutout\nAlready downloaded VolumeCutout data to save explicitly. If called this way, the bounds and mip arguments will not apply. If a precomputed image is not provided, bounds must be specified to download the cutout data. By default None\nNone\n\n\nslice_axis\nint\nIf the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)\n2\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\nverbose\nbool\nIf True, prints the progress, by default False\nFalse\n\n\n\n\n\n\n\nimagery.ImageryClient.save_segmentation_masks(filename_prefix, bounds=None, mip=None, root_ids='all', precomputed_masks=None, segmentation_colormap={}, slice_axis=2, include_null_root=False, bbox_size=None, image_size=None, resolution=None, timestamp=None, scale_to_bounds=None, verbose=False, **kwargs)\nSave queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename_prefix\nstr\nPrefix for the segmentation filenames. The full filename will be either {filename_prefix}root_id{root_id}.png or {filename_prefix}root_id{root_id}_{i}.png, depending on if multiple slices of each root id are saved.\nrequired\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution specified. Only used if a precomputed segmentation is not passed. By default, None.\nNone\n\n\nmip\nint\nOnly used if a precomputed segmentation is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None\nNone\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.\n'all'\n\n\nprecomputed_masks\ndict\nAlready downloaded dict of mask data to save explicitly. If called this way, the bounds and mip arguments will not apply. If precomputed_masks are not provided, bounds must be given to download cutout data. By default None\nNone\n\n\nsegmentation_colormap\ndict\nA dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.\n{}\n\n\nslice_axis\nint\nIf the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)\n2\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.\nFalse\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\n\n\n\n\n\nimagery.ImageryClient.segmentation_bbox_size_from_dimensions(image_size, mip=None, resolution=None)\nGet the bbox_size equivalent for an segmentation cutout with specified pixel dimensions\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nimage_size\n\nImage size in pixels (2-element) or voxels (3-element)\nrequired\n\n\nmip\n\nMip for which the image would be computed. Defaults to None, which uses the client default.\nNone\n\n\nresolution\n\nResolution to use for the bbox_size. Defaults to None, or the client defauls.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\n\nArgument for bbox_size that would give the desired pixel dimensions.\n\n\n\n\n\n\n\nimagery.ImageryClient.segmentation_cutout(bounds, root_ids='all', bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)\nGet a cutout of the segmentation imagery for some or all root ids between set bounds. Note that if all root ids are requested in a large region, it could take a long time to query all supervoxels.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.\nrequired\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default ‘all’\n'all'\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nmip\nint\nMip level of the segmentation if something other than the defualt is wanted, by default None\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\nconvert_to_int64\nbool\nIf True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nnumpy.numpy.ndarray\nArray whose elements correspond to the root id (or, if root_ids=None, the supervoxel id) at each voxel.\n\n\n\n\n\n\n\nimagery.ImageryClient.split_segmentation_cutout(bounds, root_ids='all', include_null_root=False, bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None)\nGenerate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.\nrequired\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default ‘all’\n'all'\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.\nFalse\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nmip\nint\nMip level of the segmentation if something other than the default is wanted, by default None\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nDict whose keys are root ids and whose values are the binary mask for that root id, with a 1 where the object contains the voxel."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#parameters",
    "href": "reference/imagery.ImageryClient.html#parameters",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nclient\ncaveclient.caveclient.CAVEclient or None\nA pre-initialized CAVEclient to use for configuration. If used, the image source and segmentation source come from the info service values.\nNone\n\n\nresolution\narray - like or image or segmentation\nSets the voxel resolution that bounds will be entered in, by default ‘image’, which is the mip 0 resolution of the imagery.\nNone\n\n\nsegmentation\nbool\nIf False, no segmentation cloudvolume is initialized. By default True\nTrue\n\n\nimagery\nbool\nIf False, no imagery cloudvolume is initialized. By default True\nTrue\n\n\nimage_source\nstr\nCloudVolume path to an imagery source, by default None\nNone\n\n\nsegmentation_source\nstr\nCloudVolume path to a segmentation source, by default None\nNone\n\n\nimage_mip\nint\nDefault mip level to use for imagery lookups, by default 0. Note that the same mip level for imagery and segmentation can correspond to different voxel resolutions.\nNone\n\n\nsegmentation_mip\nint\nDefault mip level to use for segmentation lookups, by default 0.\nNone\n\n\nauth_token\nstr or None\nAuth token to use for cloudvolume. If None, uses the default values from the CAVEclient. Default is None.\nNone\n\n\ntimestamp\n(datetime.datetime.datetime or None)\nFixed timestamp to use for segmentation lookups. If None, defaults to the present time when each function is run. Default is None.\nNone"
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#attributes",
    "href": "reference/imagery.ImageryClient.html#attributes",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nimage_cv\nImagery CloudVolume\n\n\nimage_source\nImage cloudpath\n\n\nresolution\nThe voxel resolution assumed when locations are used for the client.\n\n\nsegmentation_cv\nSegmentation CloudVolume object\n\n\nsegmentation_source\nSegmentation cloudpath"
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#methods",
    "href": "reference/imagery.ImageryClient.html#methods",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nimage_and_segmentation_cutout\nDownload aligned and scaled imagery and segmentation data at a given resolution.\n\n\nimage_bbox_size_from_dimensions\nGet the bbox_size equivalent for an imagery cutout with specified pixel dimensions\n\n\nimage_cutout\nGet an image cutout for a certain location or set of bounds and a mip level.\n\n\nsave_image_and_segmentation_masks\nSave aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.\n\n\nsave_imagery\nSave queried or precomputed imagery to png files.\n\n\nsave_segmentation_masks\nSave queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.\n\n\nsegmentation_bbox_size_from_dimensions\nGet the bbox_size equivalent for an segmentation cutout with specified pixel dimensions\n\n\nsegmentation_cutout\nGet a cutout of the segmentation imagery for some or all root ids between set bounds.\n\n\nsplit_segmentation_cutout\nGenerate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.image_and_segmentation_cutout",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.image_and_segmentation_cutout",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.image_and_segmentation_cutout(bounds, image_mip=None, segmentation_mip=None, root_ids='all', resize=True, split_segmentations=False, include_null_root=False, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)\nDownload aligned and scaled imagery and segmentation data at a given resolution.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.\nrequired\n\n\nimage_mip\nint\nMip level of the imagery if something other than the default is wanted, by default None\nNone\n\n\nsegmentation_mip\nint\nMip level of the segmentation if something other than the default is wanted, by default None\nNone\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.\n'all'\n\n\nresize\nbool\nIf True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).\nTrue\n\n\nsplit_segmentations\nbool\nIf True, the segmentation is returned as a dict of masks (using split_segmentation_cutout), and if False returned as an array with root_ids (using segmentation_cutout), by default False\nFalse\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.\nFalse\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\nconvert_to_int64\nbool\nIf True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ncloudvolume.cloudvolume.VolumeCutout\nImagery volume cutout\n\n\nnumpy.numpy.ndarray or dict\nSegmentation volume cutout as either an ndarray or dict of masks depending on the split_segmentations flag."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.image_bbox_size_from_dimensions(image_size, mip=None, resolution=None)\nGet the bbox_size equivalent for an imagery cutout with specified pixel dimensions\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nimage_size\n\nImage size in pixels (2-element) or voxels (3-element)\nrequired\n\n\nmip\n\nMip for which the image would be computed. Defaults to None, which uses the client default.\nNone\n\n\nresolution\n\nResolution to use for the bbox_size. Defaults to None, or the client defauls.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\n\nArgument for bbox_size that would give the desired pixel dimensions."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.image_cutout",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.image_cutout",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.image_cutout(bounds, bbox_size=None, image_size=None, mip=None, resolution=None, scale_to_bounds=None)\nGet an image cutout for a certain location or set of bounds and a mip level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\narray\nEither a 2x3 array of a lower bound and upper bound point to bound the cutout in units of voxels in a resolution set by the base_resolution parameter. Alternatively, if bbox_size or image_size is set, bounds should be a 3-element array specifying the center of the field of view.\nrequired\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nmip\nint\nMip level of imagery to get if something other than the default is wanted, by default None.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\nscale_to_bounds\nbool, optional.\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ncloudvolume.VolumeCutout\nAn n-d image of the image requested with image intensity values as the elements."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.save_image_and_segmentation_masks(filename_prefix, bounds=None, image_mip=None, segmentation_mip=None, root_ids='all', include_null_root=False, segmentation_colormap={}, resize=True, precomputed_data=None, slice_axis=2, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, **kwargs)\nSave aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename_prefix\nstr\nPrefix for the segmentation filenames. The full filename will be either {filename_prefix}root_id{root_id}.png or {filename_prefix}root_id{root_id}_{i}.png, depending on if multiple slices of each root id are saved.\nrequired\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed data is not passed. By default, None.\nNone\n\n\nimage_mip\nint\nOnly used if a precomputed data is not passed. Mip level of imagery to get if something other than the default is wanted, by default None.\nNone\n\n\nsegmentation_mip\nint\nOnly used if precomputed data is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None\nNone\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.\n'all'\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. By default, False.\nFalse\n\n\nsegmentation_colormap\ndict\nA dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.\n{}\n\n\nresize\nbool\nIf True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).\nTrue\n\n\nprecomputed_data\ntuple\nAlready computed tuple with imagery and segmentation mask data, in that order. If not provided, bounds must be given to download cutout data. By default, None.\nNone\n\n\nslice_axis\nint\nIf the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)\n2\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nresolution\nlist - like\nVoxel resolution of the bounds provided. If not provided, uses the client defaults.\nNone\n\n\ntimestamp\ndatetime\nTimestamp to use for the segmentation. If not provided, defaults to the client defaults.\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone"
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.save_imagery",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.save_imagery",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.save_imagery(filename_prefix, bounds=None, mip=None, precomputed_image=None, slice_axis=2, bbox_size=None, image_size=None, resolution=None, scale_to_bounds=None, verbose=False, **kwargs)\nSave queried or precomputed imagery to png files.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename_prefix\nstr\nPrefix for the imagery filename. The full filename will be {filename_prefix}_imagery.png\nrequired\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed image is not passed. By default, None.\nNone\n\n\nmip\nint\nOnly used if a precomputed image is not passed. Mip level of imagery to get if something other than the default is wanted, by default None\nNone\n\n\nprecomputed_image\ncloudvolume.cloudvolume.VolumeCutout\nAlready downloaded VolumeCutout data to save explicitly. If called this way, the bounds and mip arguments will not apply. If a precomputed image is not provided, bounds must be specified to download the cutout data. By default None\nNone\n\n\nslice_axis\nint\nIf the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)\n2\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\nverbose\nbool\nIf True, prints the progress, by default False\nFalse"
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.save_segmentation_masks",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.save_segmentation_masks",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.save_segmentation_masks(filename_prefix, bounds=None, mip=None, root_ids='all', precomputed_masks=None, segmentation_colormap={}, slice_axis=2, include_null_root=False, bbox_size=None, image_size=None, resolution=None, timestamp=None, scale_to_bounds=None, verbose=False, **kwargs)\nSave queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename_prefix\nstr\nPrefix for the segmentation filenames. The full filename will be either {filename_prefix}root_id{root_id}.png or {filename_prefix}root_id{root_id}_{i}.png, depending on if multiple slices of each root id are saved.\nrequired\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution specified. Only used if a precomputed segmentation is not passed. By default, None.\nNone\n\n\nmip\nint\nOnly used if a precomputed segmentation is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None\nNone\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.\n'all'\n\n\nprecomputed_masks\ndict\nAlready downloaded dict of mask data to save explicitly. If called this way, the bounds and mip arguments will not apply. If precomputed_masks are not provided, bounds must be given to download cutout data. By default None\nNone\n\n\nsegmentation_colormap\ndict\nA dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.\n{}\n\n\nslice_axis\nint\nIf the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e. z-axis)\n2\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.\nFalse\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone"
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.segmentation_bbox_size_from_dimensions(image_size, mip=None, resolution=None)\nGet the bbox_size equivalent for an segmentation cutout with specified pixel dimensions\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nimage_size\n\nImage size in pixels (2-element) or voxels (3-element)\nrequired\n\n\nmip\n\nMip for which the image would be computed. Defaults to None, which uses the client default.\nNone\n\n\nresolution\n\nResolution to use for the bbox_size. Defaults to None, or the client defauls.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\n\nArgument for bbox_size that would give the desired pixel dimensions."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.segmentation_cutout",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.segmentation_cutout",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.segmentation_cutout(bounds, root_ids='all', bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)\nGet a cutout of the segmentation imagery for some or all root ids between set bounds. Note that if all root ids are requested in a large region, it could take a long time to query all supervoxels.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.\nrequired\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default ‘all’\n'all'\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nmip\nint\nMip level of the segmentation if something other than the defualt is wanted, by default None\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\nconvert_to_int64\nbool\nIf True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nnumpy.numpy.ndarray\nArray whose elements correspond to the root id (or, if root_ids=None, the supervoxel id) at each voxel."
  },
  {
    "objectID": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.split_segmentation_cutout",
    "href": "reference/imagery.ImageryClient.html#imageryclient.imagery.ImageryClient.split_segmentation_cutout",
    "title": "imagery.ImageryClient",
    "section": "",
    "text": "imagery.ImageryClient.split_segmentation_cutout(bounds, root_ids='all', include_null_root=False, bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None)\nGenerate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\n2x3 list of ints\nA list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.\nrequired\n\n\nroot_ids\nlist, None, or ‘all’\nIf a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default ‘all’\n'all'\n\n\ninclude_null_root\nbool\nIf True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.\nFalse\n\n\nbbox_size\narray or None\nIf not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.\nNone\n\n\nimage_size\narray or None\nIf not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.\nNone\n\n\nmip\nint\nMip level of the segmentation if something other than the default is wanted, by default None\nNone\n\n\nresolution\nlist - like\nVoxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.\nNone\n\n\ntimestamp\ndatetime or None\nTimestamp to use for dynamic segmentation data\nNone\n\n\nscale_to_bounds\nbool or None\nIf True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nDict whose keys are root ids and whose values are the binary mask for that root id, with a 1 where the object contains the voxel."
  },
  {
    "objectID": "reference/composite.composite_overlay.html",
    "href": "reference/composite.composite_overlay.html",
    "title": "composite.composite_overlay",
    "section": "",
    "text": "composite.composite_overlay(segs, colors=None, alpha=0.2, imagery=None, outline=False, merge_outline=True, overlap=True, width=10, side='out', dim=2, palette=DEFAULT_PALETTE, h=DEFAULT_H, l=DEFAULT_L, s=DEFAULT_S)\nMake a colored composite overlay for a 3d mask from an iterable of masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsegs\n\nIterable of masked images of the same size. If a dict, colors must be a dict as well.\nrequired\n\n\ncolors\nlist-like, dict, or None\nIterable of RGB colors of the same size as masks. If a dict, masks must also be a dict and colors must have all keys in masks. If None, uses discrete_colors to generate colors.\nNone\n\n\nalpha\nfloat\nAlpha value for the overlay\n0.2\n\n\nimagery\nPIL.PIL.Image.PIL.Image.Image or None\nIf an Image, applies the overlay to the image, by default None\nNone\n\n\noutline\nbool\nIf True, produces an outline instead of a flat overay, by default False\nFalse\n\n\nmerge_outline\nbool\nIf True, the merge outline applies to the segmentation as a whole and thus internal contacts are not outlined.\nTrue\n\n\noverlap\nbool\nIf False, segmentations later in the list will not overlap segmentations earlier on the list.\nTrue\n\n\nwidth\nint\nIf outline=True, sets the width of the outline, by default 10\n10\n\n\nside\nout or ‘in’\nIf outline=True, selects if the outline is inside or outside the original segmentation mask, by default ‘out’\n'out'\n\n\ndim\nint\nDetermines axis over which slices are iterated if the data is 3 dimensional. Default is 2 (z-axis).\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist or PIL.PIL.Image.PIL.Image.Image\nImage or list of composite overlay images, optionally overlaid over provided imagery. List or single image is determined based on segmentation arrays being 2 or 3 dimensional."
  },
  {
    "objectID": "reference/composite.composite_overlay.html#parameters",
    "href": "reference/composite.composite_overlay.html#parameters",
    "title": "composite.composite_overlay",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsegs\n\nIterable of masked images of the same size. If a dict, colors must be a dict as well.\nrequired\n\n\ncolors\nlist-like, dict, or None\nIterable of RGB colors of the same size as masks. If a dict, masks must also be a dict and colors must have all keys in masks. If None, uses discrete_colors to generate colors.\nNone\n\n\nalpha\nfloat\nAlpha value for the overlay\n0.2\n\n\nimagery\nPIL.PIL.Image.PIL.Image.Image or None\nIf an Image, applies the overlay to the image, by default None\nNone\n\n\noutline\nbool\nIf True, produces an outline instead of a flat overay, by default False\nFalse\n\n\nmerge_outline\nbool\nIf True, the merge outline applies to the segmentation as a whole and thus internal contacts are not outlined.\nTrue\n\n\noverlap\nbool\nIf False, segmentations later in the list will not overlap segmentations earlier on the list.\nTrue\n\n\nwidth\nint\nIf outline=True, sets the width of the outline, by default 10\n10\n\n\nside\nout or ‘in’\nIf outline=True, selects if the outline is inside or outside the original segmentation mask, by default ‘out’\n'out'\n\n\ndim\nint\nDetermines axis over which slices are iterated if the data is 3 dimensional. Default is 2 (z-axis).\n2"
  },
  {
    "objectID": "reference/composite.composite_overlay.html#returns",
    "href": "reference/composite.composite_overlay.html#returns",
    "title": "composite.composite_overlay",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nlist or PIL.PIL.Image.PIL.Image.Image\nImage or list of composite overlay images, optionally overlaid over provided imagery. List or single image is determined based on segmentation arrays being 2 or 3 dimensional."
  },
  {
    "objectID": "reference/composite.discrete_colors.html",
    "href": "reference/composite.discrete_colors.html",
    "title": "composite.discrete_colors",
    "section": "",
    "text": "composite.discrete_colors(segs, palette=DEFAULT_PALETTE, h=DEFAULT_H, l=DEFAULT_L, s=DEFAULT_S)\nGenerate discrete colors for segmentations from a palette generator. Defaults to perceptually uniform differences with high saturation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsegs\nlist or dict\nDict or list of segmentations to provide colors for.\nrequired\n\n\npalette\n‘husl’, ‘hls’, or str\nWhich palette system to use, by default ‘husl’. Will accept anything allowed by seaborn color_palette function.\nDEFAULT_PALETTE\n\n\nh\nfloat\nHue value if husl or hls palettes are used, by default 0.01\nDEFAULT_H\n\n\nl\nfloat\nLightness if husl or hls palettes are used, by default 0.6\nDEFAULT_L\n\n\ns\nint\nSaturation if husl or hls palettes are used, by default 1\nDEFAULT_S\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList or dict\nList or dict with one color per segmentation."
  },
  {
    "objectID": "reference/composite.discrete_colors.html#parameters",
    "href": "reference/composite.discrete_colors.html#parameters",
    "title": "composite.discrete_colors",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsegs\nlist or dict\nDict or list of segmentations to provide colors for.\nrequired\n\n\npalette\n‘husl’, ‘hls’, or str\nWhich palette system to use, by default ‘husl’. Will accept anything allowed by seaborn color_palette function.\nDEFAULT_PALETTE\n\n\nh\nfloat\nHue value if husl or hls palettes are used, by default 0.01\nDEFAULT_H\n\n\nl\nfloat\nLightness if husl or hls palettes are used, by default 0.6\nDEFAULT_L\n\n\ns\nint\nSaturation if husl or hls palettes are used, by default 1\nDEFAULT_S"
  },
  {
    "objectID": "reference/composite.discrete_colors.html#returns",
    "href": "reference/composite.discrete_colors.html#returns",
    "title": "composite.discrete_colors",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList or dict\nList or dict with one color per segmentation."
  }
]